'use strict';

var events = require('events');
var crypto = require('crypto');

var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/adapters/events/EventsAdapter.ts
var EventsAdapter = class {
  constructor({
    emit,
    on,
    init
  }) {
    this.emit = emit;
    this.on = on;
    this.init = init;
  }
};

// src/adapters/events/EmitterEventsAdapter.ts
var _emitter;
var EmitterEventsAdapter = class extends EventsAdapter {
  constructor() {
    super({
      emit: (event, data) => {
        __privateGet(this, _emitter).emit(event, data);
        return Promise.resolve();
      },
      on: (event, fn) => {
        __privateGet(this, _emitter).on(event, (data) => {
          return fn(data, event);
        });
        return Promise.resolve();
      }
    });
    __privateAdd(this, _emitter, new events.EventEmitter());
  }
};
_emitter = new WeakMap();

// src/adapters/https/HttpAdapter.ts
var HTTPAdapter = class {
  constructor({
    setResHeaders,
    writeRes,
    flushResHeaders,
    endRes,
    onCloseCallback
  }) {
    this.setResHeaders = setResHeaders;
    this.writeRes = writeRes;
    this.flushResHeaders = flushResHeaders;
    this.endRes = endRes;
    this.onCloseCallback = onCloseCallback;
  }
};

// src/adapters/https/ExpressHttpAdapter.ts
var ExpressHttpAdapter = class extends HTTPAdapter {
  constructor() {
    super({
      setResHeaders: (res, headers) => {
        Object.entries(headers).forEach(([k, v]) => res.set(k, v));
      },
      writeRes: (res, data) => {
        res.write(data);
        const resWithFlush = res;
        if (typeof resWithFlush.flush === "function") {
          resWithFlush.flush();
        }
      },
      flushResHeaders: (res) => {
        res.flushHeaders();
      },
      endRes: (res) => {
        res.end();
      },
      onCloseCallback: (res, fn) => {
        res.on("close", fn);
      }
    });
  }
};

// src/adapters/https/FastifyHttpAdapter.ts
var FastifyHttpAdapter = class extends HTTPAdapter {
  constructor() {
    super({
      setResHeaders: (res, headers) => {
        Object.entries(headers).forEach(([k, v]) => res.raw.setHeader(k, v));
      },
      writeRes: (res, data) => {
        res.raw.flushHeaders();
        res.raw.write(data);
        res.raw.flushHeaders();
      },
      flushResHeaders: (res) => {
        res.raw.flushHeaders();
      },
      endRes: (res) => {
        res.raw.end();
      },
      onCloseCallback: (res, fn) => {
        res.raw.on("close", fn);
      }
    });
  }
};

// src/adapters/events/PostgresEventsAdapter.ts
var _client;
var PostgresEventsAdapter = class extends EventsAdapter {
  constructor(client) {
    super({
      emit: (event, data) => __async(this, null, function* () {
        yield __privateGet(this, _client).notify(event, data);
      }),
      on: (event, fn) => __async(this, null, function* () {
        yield __privateGet(this, _client).listen(event, (data) => fn(data, event));
      })
    });
    __privateAdd(this, _client, void 0);
    __privateSet(this, _client, client);
  }
};
_client = new WeakMap();

// src/index.ts
var _keepAliveInterval;
var SSEManager = class extends events.EventEmitter {
  constructor(options) {
    super();
    this.sseStreams = {};
    this.rooms = {};
    __privateAdd(this, _keepAliveInterval, void 0);
    this.id = crypto.randomBytes(16).toString("hex");
    this.httpAdapter = (options == null ? void 0 : options.httpAdapter) || new ExpressHttpAdapter();
    this.eventsAdapter = (options == null ? void 0 : options.eventsAdapter) || new EmitterEventsAdapter();
    __privateSet(this, _keepAliveInterval, typeof (options == null ? void 0 : options.keepAliveInterval) !== "undefined" ? options.keepAliveInterval : 15e3);
  }
  init() {
    return __async(this, null, function* () {
      if (this.eventsAdapter.init) {
        yield this.eventsAdapter.init();
      }
      yield Promise.all([
        this.eventsAdapter.on("broadcast", (data) => {
          const { id, message } = JSON.parse(data);
          if (this.sseStreams[id]) {
            this.sseStreams[id].broadcast(message);
          } else if (this.rooms[id]) {
            Object.values(this.rooms[id]).forEach((sseStream) => {
              sseStream.broadcast(message);
            });
          }
        }),
        this.eventsAdapter.on("closeSSEStream", (data) => {
          const { id } = JSON.parse(data);
          if (this.sseStreams[id]) {
            this.sseStreams[id].close();
          } else if (this.rooms[id]) {
            Object.values(this.rooms[id]).forEach((sseStream) => {
              sseStream.close();
            });
          }
        }),
        this.eventsAdapter.on("addSSEStreamToRoom", (data) => {
          const { streamId, roomId } = JSON.parse(data);
          if (this.sseStreams[streamId]) {
            if (!this.rooms[roomId]) {
              this.rooms[roomId] = [];
            }
            this.rooms[roomId].push(this.sseStreams[streamId]);
          }
        }),
        this.eventsAdapter.on("removeSSEStreamFromRoom", (data) => {
          var _a, _b;
          const { streamId, roomId } = JSON.parse(data);
          if (this.sseStreams[streamId]) {
            (_b = this.rooms[roomId]) == null ? void 0 : _b.splice((_a = this.rooms[roomId]) == null ? void 0 : _a.indexOf(this.sseStreams[streamId]), 1);
          }
        }),
        this.eventsAdapter.on("closeRoom", (data) => {
          const { roomId } = JSON.parse(data);
          if (this.rooms[roomId]) {
            this.rooms[roomId].forEach((sseStream) => {
              sseStream.close();
            });
            delete this.rooms[roomId];
          }
        })
      ]);
    });
  }
  createSSEStream(_0) {
    return __async(this, arguments, function* (res, options = { keepAliveInterval: __privateGet(this, _keepAliveInterval) }) {
      const sseStream = new SSEStream(res, this, options);
      this.sseStreams[sseStream.id] = sseStream;
      sseStream.on("close", () => __async(this, null, function* () {
        this.sseStreams[sseStream.id].rooms.forEach((roomId) => {
          const room = this.rooms[roomId];
          for (let i = 0; i < room.length; i++) {
            if (room[i].id === sseStream.id) {
              room.splice(i, 1);
              break;
            }
          }
          if (!room.length) {
            delete this.rooms[roomId];
          }
        });
        delete this.sseStreams[sseStream.id];
      }));
      return sseStream;
    });
  }
  broadcast(id, message) {
    return __async(this, null, function* () {
      if (this.sseStreams[id]) {
        this.sseStreams[id].broadcast(message);
      } else {
        yield this.eventsAdapter.emit("broadcast", JSON.stringify({ id, message }));
      }
    });
  }
  closeSSEStream(id) {
    return __async(this, null, function* () {
      if (this.sseStreams[id]) {
        this.sseStreams[id].close();
      } else {
        yield this.eventsAdapter.emit("closeSSEStream", JSON.stringify({ id }));
      }
    });
  }
  addSSEStreamToRoom(streamId, roomId) {
    return __async(this, null, function* () {
      if (this.sseStreams[streamId]) {
        if (!this.rooms[roomId]) {
          this.rooms[roomId] = [];
        }
        this.rooms[roomId].push(this.sseStreams[streamId]);
        this.sseStreams[streamId].rooms.push(roomId);
      } else {
        yield this.eventsAdapter.emit("addSSEStreamToRoom", JSON.stringify({ streamId, roomId }));
      }
    });
  }
  removeSSEStreamFromRoom(streamId, roomId) {
    return __async(this, null, function* () {
      var _a, _b;
      if (this.sseStreams[streamId]) {
        (_b = this.rooms[roomId]) == null ? void 0 : _b.splice((_a = this.rooms[roomId]) == null ? void 0 : _a.indexOf(this.sseStreams[streamId]), 1);
      } else {
        yield this.eventsAdapter.emit("removeSSEStreamFromRoom", JSON.stringify({ streamId, roomId }));
      }
    });
  }
  closeRoom(roomId) {
    return __async(this, null, function* () {
      yield this.eventsAdapter.emit("closeRoom", JSON.stringify({ roomId }));
    });
  }
};
_keepAliveInterval = new WeakMap();
var createSSEManager = (options) => __async(void 0, null, function* () {
  const sseManager = new SSEManager(options);
  yield sseManager.init();
  return sseManager;
});
var _keepAliveTimeout, _setKeepAliveInterval;
var SSEStream = class extends events.EventEmitter {
  constructor(res, sseManager, options) {
    super();
    __privateAdd(this, _keepAliveTimeout, null);
    __privateAdd(this, _setKeepAliveInterval, () => {
      if (__privateGet(this, _keepAliveTimeout)) {
        clearTimeout(__privateGet(this, _keepAliveTimeout));
      }
      if (this.options.keepAliveInterval) {
        __privateSet(this, _keepAliveTimeout, setTimeout(() => {
          this.keepAlive();
          __privateGet(this, _setKeepAliveInterval).call(this);
        }, this.options.keepAliveInterval));
      }
    });
    this.id = crypto.randomBytes(16).toString("hex");
    this.res = res;
    this.sseManager = sseManager;
    this.rooms = [];
    this.options = options;
    this.closed = false;
    sseManager.httpAdapter.setResHeaders(res, {
      "Cache-Control": "no-cache",
      "Content-Type": "text/event-stream",
      "Connection": "keep-alive"
    });
    sseManager.httpAdapter.flushResHeaders(res);
    sseManager.httpAdapter.onCloseCallback(res, () => {
      sseManager.httpAdapter.endRes(res);
      this.closed = true;
      if (__privateGet(this, _keepAliveTimeout)) {
        clearTimeout(__privateGet(this, _keepAliveTimeout));
      }
      this.emit("close");
    });
    this.on("data", (data) => sseManager.httpAdapter.writeRes(res, data));
    this.on("end", () => sseManager.httpAdapter.endRes(res));
    __privateGet(this, _setKeepAliveInterval).call(this);
  }
  keepAlive() {
    this.sseManager.httpAdapter.writeRes(this.res, ":keep-alive\n\n");
  }
  broadcast(message) {
    this.emit("data", `${Object.entries(message).map(([k, v]) => `${k}: ${v}`).join("\n")}

`);
    __privateGet(this, _setKeepAliveInterval).call(this);
  }
  close() {
    this.emit("end");
  }
  addToRoom(id) {
    return this.sseManager.addSSEStreamToRoom(this.id, id);
  }
  removeFromRoom(id) {
    return this.sseManager.removeSSEStreamFromRoom(this.id, id);
  }
};
_keepAliveTimeout = new WeakMap();
_setKeepAliveInterval = new WeakMap();

exports.EmitterEventsAdapter = EmitterEventsAdapter;
exports.EventsAdapter = EventsAdapter;
exports.ExpressHttpAdapter = ExpressHttpAdapter;
exports.FastifyHttpAdapter = FastifyHttpAdapter;
exports.HTTPAdapter = HTTPAdapter;
exports.PostgresEventsAdapter = PostgresEventsAdapter;
exports.SSEManager = SSEManager;
exports.SSEStream = SSEStream;
exports.createSSEManager = createSSEManager;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.js.map