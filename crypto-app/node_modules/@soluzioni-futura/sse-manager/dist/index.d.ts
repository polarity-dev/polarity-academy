import { EventEmitter } from 'events';
import postgres from 'postgres';

declare type EventsAdapterEmitFn = (event: string, data: string) => Promise<void>;
declare type EventsAdapterOnFn = (event: string, fn: (data: string, event: string) => void) => Promise<void>;
declare type EventsAdapterInitFn = () => Promise<void>;
declare class EventsAdapter {
    emit: EventsAdapterEmitFn;
    on: EventsAdapterOnFn;
    init?: EventsAdapterInitFn;
    constructor({ emit, on, init }: {
        emit: EventsAdapterEmitFn;
        on: EventsAdapterOnFn;
        init?: EventsAdapterInitFn;
    });
}

declare class EmitterEventsAdapter extends EventsAdapter {
    #private;
    constructor();
}

declare type HTTPAdapterSetResHeadersFn = (res: any, headers: {
    [key: string]: string;
}) => void;
declare type HTTPAdapterWriteResFn = (res: any, data: string) => void;
declare type HTTPFlushResHeadersFn = (res: any) => void;
declare type HTTPEndResHeadersFn = (res: any) => void;
declare type HTTPResOnCloseCallbackFn = (res: any, fn: () => void) => void;
declare class HTTPAdapter {
    setResHeaders: HTTPAdapterSetResHeadersFn;
    writeRes: HTTPAdapterWriteResFn;
    flushResHeaders: HTTPFlushResHeadersFn;
    endRes: HTTPEndResHeadersFn;
    onCloseCallback: HTTPResOnCloseCallbackFn;
    constructor({ setResHeaders, writeRes, flushResHeaders, endRes, onCloseCallback }: {
        setResHeaders: HTTPAdapterSetResHeadersFn;
        writeRes: HTTPAdapterWriteResFn;
        flushResHeaders: HTTPFlushResHeadersFn;
        endRes: HTTPEndResHeadersFn;
        onCloseCallback: HTTPResOnCloseCallbackFn;
    });
}

declare class ExpressHttpAdapter extends HTTPAdapter {
    constructor();
}

declare class FastifyHttpAdapter extends HTTPAdapter {
    constructor();
}

declare class PostgresEventsAdapter extends EventsAdapter {
    #private;
    constructor(client: ReturnType<typeof postgres>);
}

declare type SSEManagerOptions = {
    httpAdapter?: HTTPAdapter;
    eventsAdapter?: EventsAdapter;
    keepAliveInterval?: number | null;
};
declare type SSEMessage = {
    data: string;
    id?: number | string;
    channel?: string;
    retry?: number;
};
declare type SSEStreamOptions = {
    keepAliveInterval: number | null;
};
declare class SSEManager extends EventEmitter {
    #private;
    readonly id: string;
    httpAdapter: HTTPAdapter;
    eventsAdapter: EventsAdapter;
    sseStreams: {
        [id: string]: SSEStream;
    };
    rooms: {
        [id: string]: SSEStream[];
    };
    constructor(options?: SSEManagerOptions);
    init(): Promise<void>;
    createSSEStream(res: any, options?: SSEStreamOptions): Promise<SSEStream>;
    broadcast(id: string, message: SSEMessage): Promise<void>;
    closeSSEStream(id: string): Promise<void>;
    addSSEStreamToRoom(streamId: string, roomId: string): Promise<void>;
    removeSSEStreamFromRoom(streamId: string, roomId: string): Promise<void>;
    closeRoom(roomId: string): Promise<void>;
}
declare const createSSEManager: (options?: SSEManagerOptions) => Promise<SSEManager>;
declare class SSEStream extends EventEmitter {
    #private;
    readonly id: string;
    readonly res: any;
    readonly sseManager: SSEManager;
    readonly rooms: string[];
    readonly options: SSEStreamOptions;
    closed: boolean;
    constructor(res: any, sseManager: SSEManager, options: SSEStreamOptions);
    keepAlive(): void;
    broadcast(message: SSEMessage): void;
    close(): void;
    addToRoom(id: string): Promise<void>;
    removeFromRoom(id: string): Promise<void>;
}

export { EmitterEventsAdapter, EventsAdapter, ExpressHttpAdapter, FastifyHttpAdapter, HTTPAdapter, PostgresEventsAdapter, SSEManager, SSEManagerOptions, SSEMessage, SSEStream, SSEStreamOptions, createSSEManager };
